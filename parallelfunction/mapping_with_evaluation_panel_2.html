<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Alphabet Systems f(x), g(x), Cosine Sound, Waveform, JSON</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #ffffff;
      color: #000000;
    }
    .container {
      max-width: 600px;
      min-width: 320px;
      margin: 0 auto;
      padding: 16px;
      border: 1px solid #ccc;
      box-sizing: border-box;
    }
    h1, h2 {
      font-size: 18px;
      margin: 8px 0;
      text-align: center;
    }
    h2 {
      font-size: 14px;
      text-align: left;
      margin-top: 14px;
    }
    p.desc {
      font-size: 12px;
      line-height: 1.4;
      margin: 0 0 12px;
    }
    .letter-strip {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-bottom: 12px;
      justify-content: center;
    }
    .letter-btn {
      border: 1px solid #333;
      padding: 2px 6px;
      font-size: 11px;
      cursor: pointer;
      background: #f7f7f7;
      border-radius: 3px;
      user-select: none;
    }
    .letter-btn.active {
      background: #000000;
      color: #ffffff;
    }
    .selected-box {
      border: 1px solid #999;
      padding: 8px;
      margin-bottom: 12px;
      font-size: 12px;
      background: #fafafa;
    }
    .selected-box div {
      margin: 2px 0;
    }
    .selected-label {
      font-weight: bold;
    }

    .eval-panel,
    .sound-panel,
    .wave-panel,
    .json-panel {
      border: 1px solid #999;
      padding: 8px;
      margin-bottom: 12px;
      font-size: 12px;
      background: #fdfdfd;
    }
    .eval-panel label,
    .sound-panel label,
    .json-panel label {
      display: block;
      margin: 4px 0;
      font-size: 12px;
    }
    .eval-panel input {
      width: 100%;
      padding: 4px;
      box-sizing: border-box;
      font-size: 12px;
    }
    .eval-panel button,
    .sound-panel button,
    .json-panel button {
      margin-top: 6px;
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
      border-radius: 3px;
      border: 1px solid #333;
      background: #f3f3f3;
    }
    .eval-output,
    .sound-info {
      margin-top: 6px;
      font-size: 11px;
      line-height: 1.4;
      white-space: pre-line;
    }

    .wave-panel canvas {
      width: 100%;
      max-width: 560px;
      height: 140px;
      border: 1px solid #ccc;
      background: #ffffff;
      display: block;
      margin: 6px auto 0 auto;
    }
    .wave-caption {
      font-size: 11px;
      margin-top: 4px;
      color: #333;
    }

    .json-panel textarea {
      width: 100%;
      min-height: 120px;
      font-family: "Courier New", monospace;
      font-size: 11px;
      box-sizing: border-box;
      margin-top: 6px;
      white-space: pre;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 4px;
      text-align: left;
      vertical-align: top;
    }
    th {
      background: #f0f0f0;
    }
    .letter-col {
      width: 10%;
      text-align: center;
      font-weight: bold;
    }
    .footer-note {
      font-size: 10px;
      margin-top: 10px;
      color: #333;
    }
    @media print {
      .letter-btn {
        border: 1px solid #000;
      }
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Alphabet Systems f(x), g(x) with Sound, Waveform, and JSON</h1>
  <p class="desc">
    Each letter A through Z is assigned a pair of equations in two systems,
    <strong>f(x)</strong> and <strong>g(x)</strong>. Select a letter to see its
    equations, evaluate them at a chosen x, and then generate a cosine-based
    sound and waveform. You can also export the system and the latest sound
    parameters as JSON.
  </p>

  <!-- Letter selector -->
  <div class="letter-strip" id="letterStrip">
    <!-- buttons generated by script -->
  </div>

  <!-- Selected letter symbolic display -->
  <div class="selected-box" id="selectedBox">
    <div><span class="selected-label">Letter:</span> <span id="selLetter">A</span></div>
    <div><span class="selected-label">f(x):</span> <span id="selF">f(x) = x + 1</span></div>
    <div><span class="selected-label">g(x):</span> <span id="selG">g(x) = 1/x</span></div>
  </div>

  <!-- Evaluation panel -->
  <div class="eval-panel">
    <h2>Evaluate f(x) and g(x)</h2>
    <p class="desc">
      The active letter is the one highlighted in the strip above. Enter a numeric
      value for x and press Evaluate to see numeric values for f(x) and g(x). The
      evaluation also prepares amplitude and frequency for the cosine mapping.
    </p>
    <label for="xInput">
      x value:
    </label>
    <input type="number" id="xInput" step="0.1" value="1">
    <button id="evalButton">Evaluate for current letter</button>
    <div class="eval-output" id="evalOutput">
      Waiting for evaluation. Choose a letter and press Evaluate.
    </div>
  </div>

  <!-- Cosine sound panel -->
  <div class="sound-panel">
    <h2>Cosine Sound Mapping: y(t) = A cos(2π f t)</h2>
    <p class="desc">
      After evaluation, the system derives an amplitude A from f(x) and a frequency
      f in Hz from g(x). Press the button to hear a short tone generated from the
      current letter and x value.
    </p>
    <button id="playButton">Play tone from current letter and x</button>
    <div class="sound-info" id="soundInfo">
      Sound parameters are not ready yet. Evaluate f(x) and g(x) first.
    </div>
  </div>

  <!-- Waveform preview panel -->
  <div class="wave-panel">
    <h2>Waveform Preview</h2>
    <p class="desc">
      This canvas shows a segment of y(t) = A cos(2π f t) using the latest values of
      amplitude A and frequency f. The horizontal axis represents time in seconds
      over a short window. The vertical axis shows the waveform value between −1 and 1
      scaled by A.
    </p>
    <canvas id="waveCanvas" width="560" height="140"></canvas>
    <div class="wave-caption" id="waveCaption">
      No waveform yet. Evaluate a letter and x value to draw the wave.
    </div>
  </div>

  <!-- JSON export panel -->
  <div class="json-panel">
    <h2>JSON Export</h2>
    <p class="desc">
      Use these buttons to view JSON for the full alphabet system (symbolic f(x) and g(x))
      and for the latest evaluated sound parameters. You can copy this JSON into other
      tools or scripts.
    </p>
    <button id="exportSystemButton">Show system JSON (all letters)</button>
    <button id="exportLastButton">Show last evaluation JSON</button>
    <textarea id="jsonOutput" readonly>
Press one of the buttons above to populate this JSON view.
    </textarea>
  </div>

  <!-- Full reference table -->
  <table>
    <thead>
      <tr>
        <th class="letter-col">Letter</th>
        <th>f(x)</th>
        <th>g(x)</th>
      </tr>
    </thead>
    <tbody id="eqTableBody">
      <!-- rows generated by script -->
    </tbody>
  </table>

  <div class="footer-note">
    Note: Functions use standard notation such as sin(x), cos(x), ln(x), e^x,
    tanh(x), and so on. Evaluation uses JavaScript Math functions and will report
    an error if x is outside the domain of a given function.
  </div>
</div>

<script>
  // ============================================================
  // Data structure: f(x), g(x) definitions for letters A to Z
  // Each entry contains:
  //   letter:  display letter
  //   fStr:    symbolic display string for f(x)
  //   gStr:    symbolic display string for g(x)
  //   f(x):    numeric implementation for evaluation
  //   g(x):    numeric implementation for evaluation
  // ============================================================
  const eqData = [
    {
      letter: "A",
      fStr: "f(x) = x + 1",
      gStr: "g(x) = 1/x",
      f: function (x) { return x + 1; },
      g: function (x) { return x === 0 ? NaN : 1 / x; }
    },
    {
      letter: "B",
      fStr: "f(x) = x\u00b2 + 2",
      gStr: "g(x) = 2x - x\u00b2",
      f: function (x) { return x * x + 2; },
      g: function (x) { return 2 * x - x * x; }
    },
    {
      letter: "C",
      fStr: "f(x) = 3x - 2",
      gStr: "g(x) = 3sin(x)",
      f: function (x) { return 3 * x - 2; },
      g: function (x) { return 3 * Math.sin(x); }
    },
    {
      letter: "D",
      fStr: "f(x) = x\u00b3 - 3x",
      gStr: "g(x) = 4cos(x)",
      f: function (x) { return x * x * x - 3 * x; },
      g: function (x) { return 4 * Math.cos(x); }
    },
    {
      letter: "E",
      fStr: "f(x) = \u221a(x + 4)",
      gStr: "g(x) = 5e^{-x}",
      f: function (x) { return x + 4 < 0 ? NaN : Math.sqrt(x + 4); },
      g: function (x) { return 5 * Math.exp(-x); }
    },
    {
      letter: "F",
      fStr: "f(x) = |x| + 5",
      gStr: "g(x) = 6ln(x + 1)",
      f: function (x) { return Math.abs(x) + 5; },
      g: function (x) { return x + 1 <= 0 ? NaN : 6 * Math.log(x + 1); }
    },
    {
      letter: "G",
      fStr: "f(x) = sin(x) + 6",
      gStr: "g(x) = 7x\u00b3",
      f: function (x) { return Math.sin(x) + 6; },
      g: function (x) { return 7 * x * x * x; }
    },
    {
      letter: "H",
      fStr: "f(x) = cos(x) - 7",
      gStr: "g(x) = 8/(x\u00b2 + 1)",
      f: function (x) { return Math.cos(x) - 7; },
      g: function (x) { return 8 / (x * x + 1); }
    },
    {
      letter: "I",
      fStr: "f(x) = ln(x + 8)",
      gStr: "g(x) = 9\u221ax",
      f: function (x) { return x + 8 <= 0 ? NaN : Math.log(x + 8); },
      g: function (x) { return x < 0 ? NaN : 9 * Math.sqrt(x); }
    },
    {
      letter: "J",
      fStr: "f(x) = e^x - 9",
      gStr: "g(x) = 10x\u00b2 + sin(x)",
      f: function (x) { return Math.exp(x) - 9; },
      g: function (x) { return 10 * x * x + Math.sin(x); }
    },
    {
      letter: "K",
      fStr: "f(x) = tan(x) + 10",
      gStr: "g(x) = 11e^{x/2}",
      f: function (x) { return Math.tan(x) + 10; },
      g: function (x) { return 11 * Math.exp(x / 2); }
    },
    {
      letter: "L",
      fStr: "f(x) = x\u00b2 / 11",
      gStr: "g(x) = 12tan(x/2)",
      f: function (x) { return x * x / 11; },
      g: function (x) { return 12 * Math.tan(x / 2); }
    },
    {
      letter: "M",
      fStr: "f(x) = x\u00b3 / 12 - x",
      gStr: "g(x) = 13x\u2074 - x\u00b2",
      f: function (x) { return x * x * x / 12 - x; },
      g: function (x) { return 13 * x * x * x * x - x * x; }
    },
    {
      letter: "N",
      fStr: "f(x) = x\u00b2 - 13x + 13",
      gStr: "g(x) = 14cos(2x)",
      f: function (x) { return x * x - 13 * x + 13; },
      g: function (x) { return 14 * Math.cos(2 * x); }
    },
    {
      letter: "O",
      fStr: "f(x) = sin(\u03c0x / 14)",
      gStr: "g(x) = 15/(x + 2)",
      f: function (x) { return Math.sin(Math.PI * x / 14); },
      g: function (x) { return x === -2 ? NaN : 15 / (x + 2); }
    },
    {
      letter: "P",
      fStr: "f(x) = log\u2082(x + 15)",
      gStr: "g(x) = 16x\u00b3 - 4x",
      f: function (x) { return x + 15 <= 0 ? NaN : Math.log2(x + 15); },
      g: function (x) { return 16 * x * x * x - 4 * x; }
    },
    {
      letter: "Q",
      fStr: "f(x) = \u221a(x\u00b2 + 16)",
      gStr: "g(x) = 17sin(x\u00b2)",
      f: function (x) { return Math.sqrt(x * x + 16); },
      g: function (x) { return 17 * Math.sin(x * x); }
    },
    {
      letter: "R",
      fStr: "f(x) = e^{-x / 17}",
      gStr: "g(x) = 18\u221a(x\u00b2 + 1)",
      f: function (x) { return Math.exp(-x / 17); },
      g: function (x) { return 18 * Math.sqrt(x * x + 1); }
    },
    {
      letter: "S",
      fStr: "f(x) = 18/(x + 1)",
      gStr: "g(x) = 19log\u2081\u2080(x + 3)",
      f: function (x) { return x === -1 ? NaN : 18 / (x + 1); },
      g: function (x) {
        if (x + 3 <= 0) return NaN;
        // Math.log10 is log base 10
        return 19 * Math.log10(x + 3);
      }
    },
    {
      letter: "T",
      fStr: "f(x) = cosh(x / 19)",
      gStr: "g(x) = 20cosh(x)",
      f: function (x) { return Math.cosh(x / 19); },
      g: function (x) { return 20 * Math.cosh(x); }
    },
    {
      letter: "U",
      fStr: "f(x) = sinh(x) / 20",
      gStr: "g(x) = 21sinh(x)",
      f: function (x) { return Math.sinh(x) / 20; },
      g: function (x) { return 21 * Math.sinh(x); }
    },
    {
      letter: "V",
      fStr: "f(x) = |sin(20x)|",
      gStr: "g(x) = 22sin(3x)/x",
      f: function (x) { return Math.abs(Math.sin(20 * x)); },
      g: function (x) { return x === 0 ? NaN : 22 * Math.sin(3 * x) / x; }
    },
    {
      letter: "W",
      fStr: "f(x) = tanh(x / 21)",
      gStr: "g(x) = 23e^{-x\u00b2}",
      f: function (x) { return Math.tanh(x / 21); },
      g: function (x) { return 23 * Math.exp(-x * x); }
    },
    {
      letter: "X",
      fStr: "f(x) = (x\u2074 - 1) / 22",
      gStr: "g(x) = 24x\u00b2/(x\u00b2 + 1)",
      f: function (x) { return (x * x * x * x - 1) / 22; },
      g: function (x) { return 24 * x * x / (x * x + 1); }
    },
    {
      letter: "Y",
      fStr: "f(x) = x\u00b2 + sin(2x)",
      gStr: "g(x) = 25tan^{-1}(x)",
      f: function (x) { return x * x + Math.sin(2 * x); },
      g: function (x) { return 25 * Math.atan(x); }
    },
    {
      letter: "Z",
      fStr: "f(x) = ln(x\u00b2 + 23)",
      gStr: "g(x) = 26sin(x)cos(x)",
      f: function (x) {
        // Domain check for ln(x^2 + 23)
        return x * x + 23 <= 0 ? NaN : Math.log(x * x + 23);
      },
      g: function (x) {
        return 26 * Math.sin(x) * Math.cos(x);
      }
    }
  ];

  // DOM references
  const letterStrip = document.getElementById("letterStrip");
  const eqTableBody = document.getElementById("eqTableBody");
  const selLetter = document.getElementById("selLetter");
  const selF = document.getElementById("selF");
  const selG = document.getElementById("selG");
  const xInput = document.getElementById("xInput");
  const evalButton = document.getElementById("evalButton");
  const evalOutput = document.getElementById("evalOutput");
  const playButton = document.getElementById("playButton");
  const soundInfo = document.getElementById("soundInfo");
  const waveCanvas = document.getElementById("waveCanvas");
  const waveCaption = document.getElementById("waveCaption");
  const exportSystemButton = document.getElementById("exportSystemButton");
  const exportLastButton = document.getElementById("exportLastButton");
  const jsonOutput = document.getElementById("jsonOutput");

  let currentIndex = 0;

  // Last computed parameters for sound and waveform
  // This object holds the numeric link between letter, x, and sound
  let lastParams = {
    letter: null,
    x: null,
    fVal: null,
    gVal: null,
    amplitude: null,
    freqHz: null
  };

  // ============================================================
  // Build letter buttons and reference table rows dynamically
  // ============================================================
  eqData.forEach((item, index) => {
    // Create and append letter buttons
    const btn = document.createElement("button");
    btn.className = "letter-btn" + (index === 0 ? " active" : "");
    btn.textContent = item.letter;
    btn.dataset.index = index.toString();
    letterStrip.appendChild(btn);

    // Create and append table rows for reference
    const tr = document.createElement("tr");
    const tdL = document.createElement("td");
    const tdF = document.createElement("td");
    const tdG = document.createElement("td");

    tdL.className = "letter-col";
    tdL.textContent = item.letter;
    tdF.textContent = item.fStr;
    tdG.textContent = item.gStr;

    tr.appendChild(tdL);
    tr.appendChild(tdF);
    tr.appendChild(tdG);
    eqTableBody.appendChild(tr);
  });

  // Update the selected letter and symbolic f(x), g(x)
  function setSelected(index) {
    currentIndex = index;
    const item = eqData[index];
    selLetter.textContent = item.letter;
    selF.textContent = item.fStr;
    selG.textContent = item.gStr;

    // Highlight the active letter button
    const buttons = document.querySelectorAll(".letter-btn");
    buttons.forEach(btn => btn.classList.remove("active"));
    buttons[index].classList.add("active");
  }

  // Initialize selection to A (index 0)
  setSelected(0);

  // Handle letter selection via event delegation
  letterStrip.addEventListener("click", function (evt) {
    const target = evt.target;
    if (target.classList.contains("letter-btn")) {
      const idx = parseInt(target.dataset.index, 10);
      if (!isNaN(idx)) {
        setSelected(idx);
      }
    }
  });

  // ============================================================
  // Evaluation of f(x) and g(x) for the current letter
  // Also compute amplitude and frequency from those values
  // ============================================================
  evalButton.addEventListener("click", function () {
    const xVal = parseFloat(xInput.value);
    if (isNaN(xVal)) {
      evalOutput.textContent = "Please enter a valid numeric value for x.";
      lastParams = {
        letter: null, x: null, fVal: null, gVal: null, amplitude: null, freqHz: null
      };
      soundInfo.textContent = "Sound parameters are not ready. Please fix x and evaluate again.";
      waveCaption.textContent = "No waveform yet. Evaluation was invalid.";
      clearWaveform();
      return;
    }

    const item = eqData[currentIndex];
    let fVal = item.f(xVal);
    let gVal = item.g(xVal);

    // Check numeric validity for both f(x) and g(x)
    if (!isFinite(fVal) || !isFinite(gVal) || isNaN(fVal) || isNaN(gVal)) {
      evalOutput.textContent =
        "The chosen x value is outside the numeric domain for this letter.\n" +
        "Try a different x, or a different letter.";
      lastParams = {
        letter: null, x: null, fVal: null, gVal: null, amplitude: null, freqHz: null
      };
      soundInfo.textContent = "Sound parameters are not ready because the evaluation was invalid.";
      waveCaption.textContent = "No waveform yet. Evaluation was invalid.";
      clearWaveform();
      return;
    }

    // Normalize amplitude A from f(x)
    // ampRaw is absolute f(x). The mapping ampRaw / (1 + ampRaw) compresses
    // any nonnegative real value into an open interval (0, 1).
    const ampRaw = Math.abs(fVal);
    const amplitude = ampRaw / (1 + ampRaw);

    // Normalize frequency from g(x)
    // gAbs ensures a nonnegative base. The modulus step keeps frequency moderate.
    const gAbs = Math.abs(gVal);
    const base = gAbs < 1 ? 1 + gAbs : gAbs; // strictly positive
    const freqHz = 220 + (base % 880);       // range 220 Hz to 1100 Hz

    // Persist parameters for audio and waveform
    lastParams = {
      letter: item.letter,
      x: xVal,
      fVal: fVal,
      gVal: gVal,
      amplitude: amplitude,
      freqHz: freqHz
    };

    evalOutput.textContent =
      "Letter " + item.letter + " at x = " + xVal + " gives:\n" +
      "  f(x) = " + fVal.toFixed(6) + "\n" +
      "  g(x) = " + gVal.toFixed(6) + "\n\n" +
      "Mapped sound parameters:\n" +
      "  Amplitude A (from f(x)) = " + amplitude.toFixed(4) + " (0 to 1)\n" +
      "  Frequency f (from g(x)) = " + freqHz.toFixed(2) + " Hz";

    soundInfo.textContent =
      "Ready to play y(t) = A cos(2π f t) for letter " + item.letter +
      " at x = " + xVal + ".\n" +
      "A = " + amplitude.toFixed(4) + ", f = " + freqHz.toFixed(2) + " Hz.";

    // Draw waveform preview using the newest parameters
    drawWaveform(amplitude, freqHz);
  });

  // ============================================================
  // Web Audio: play a tone based on lastParams
  // ============================================================
  let audioCtx = null;

  function getAudioContext() {
    if (!audioCtx) {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) {
        alert("Web Audio API is not supported in this browser.");
        return null;
      }
      audioCtx = new AC();
    }
    return audioCtx;
  }

  playButton.addEventListener("click", function () {
    if (!lastParams || lastParams.amplitude === null || lastParams.freqHz === null) {
      alert("Sound parameters are not set. Please evaluate f(x) and g(x) first.");
      return;
    }

    const ctx = getAudioContext();
    if (!ctx) {
      return;
    }

    const duration = 2.0; // seconds
    const oscillator = ctx.createOscillator();
    const gainNode = ctx.createGain();

    // For a pure tone, sine and cosine differ by phase only
    oscillator.type = "sine";
    oscillator.frequency.value = lastParams.freqHz;

    gainNode.gain.value = lastParams.amplitude;

    oscillator.connect(gainNode).connect(ctx.destination);

    const now = ctx.currentTime;
    oscillator.start(now);
    oscillator.stop(now + duration);
  });

  // ============================================================
  // Waveform drawing: plot y(t) = A cos(2π f t) on the canvas
  // ============================================================
  const waveCtx = waveCanvas.getContext("2d");

  function clearWaveform() {
    waveCtx.clearRect(0, 0, waveCanvas.width, waveCanvas.height);
    // Draw center line for reference
    waveCtx.beginPath();
    waveCtx.moveTo(0, waveCanvas.height / 2);
    waveCtx.lineTo(waveCanvas.width, waveCanvas.height / 2);
    waveCtx.strokeStyle = "#cccccc";
    waveCtx.lineWidth = 1;
    waveCtx.stroke();
  }

  // Initial clear with center line
  clearWaveform();

  function drawWaveform(amplitude, freqHz) {
    const width = waveCanvas.width;
    const height = waveCanvas.height;
    const midY = height / 2;

    // Clear and draw center line
    waveCtx.clearRect(0, 0, width, height);
    waveCtx.beginPath();
    waveCtx.moveTo(0, midY);
    waveCtx.lineTo(width, midY);
    waveCtx.strokeStyle = "#cccccc";
    waveCtx.lineWidth = 1;
    waveCtx.stroke();

    // Choose a time window in seconds to render
    // With f in the range 220..1100 Hz, a window of 0.01 seconds
    // shows about 2.2 to 11 cycles across the canvas.
    const timeWindow = 0.01; // seconds
    const sampleCount = 600; // resolution

    waveCtx.beginPath();
    for (let i = 0; i < sampleCount; i++) {
      const t = (i / (sampleCount - 1)) * timeWindow; // time in seconds
      const y = amplitude * Math.cos(2 * Math.PI * freqHz * t); // waveform value

      // Map t to x pixel coordinate
      const xPixel = (i / (sampleCount - 1)) * width;

      // Map y in [-1, 1] to vertical pixel coordinate
      // y = 1 at top center line, y = -1 at bottom center line
      const yPixel = midY - y * (height / 2 - 4); // padding of 4 pixels

      if (i === 0) {
        waveCtx.moveTo(xPixel, yPixel);
      } else {
        waveCtx.lineTo(xPixel, yPixel);
      }
    }

    waveCtx.strokeStyle = "#000000";
    waveCtx.lineWidth = 1.5;
    waveCtx.stroke();

    waveCaption.textContent =
      "Waveform preview: y(t) = A cos(2π f t) over " + timeWindow + " seconds. " +
      "A = " + amplitude.toFixed(4) + ", f = " + freqHz.toFixed(2) + " Hz.";
  }

  // ============================================================
  // JSON Export
  //   1. System JSON: letters with fStr, gStr (symbolic)
  //   2. Last evaluation JSON: link between letter, x, f(x), g(x), A, f
  // ============================================================
  exportSystemButton.addEventListener("click", function () {
    // For export, it is useful to provide only metadata and symbolic strings
    // rather than the executable function bodies.
    const systemExport = eqData.map(item => ({
      letter: item.letter,
      f: item.fStr,
      g: item.gStr
    }));

    const jsonText = JSON.stringify(systemExport, null, 2);
    jsonOutput.value = jsonText;
  });

  exportLastButton.addEventListener("click", function () {
    if (!lastParams || lastParams.letter === null) {
      jsonOutput.value =
        "// No valid evaluation has been performed yet.\n" +
        "// Evaluate a letter and x value first.";
      return;
    }

    const lastExport = {
      letter: lastParams.letter,
      x: lastParams.x,
      fValue: lastParams.fVal,
      gValue: lastParams.gVal,
      amplitude: lastParams.amplitude,
      frequencyHz: lastParams.freqHz,
      equation: "y(t) = A cos(2π f t)"
    };

    const jsonText = JSON.stringify(lastExport, null, 2);
    jsonOutput.value = jsonText;
  });
</script>
</body>
</html>
