<!DOCTYPE html>
<!--
  ======================================================================
  SYSTEM DESIGN NOTES FOR f(x) AND g(x), SOUND MAPPING, AND VISUALS
  ======================================================================

  OVERVIEW
  --------
  This file implements a dual system of equations over the alphabet.
  Each letter L in {A, B, ..., Z} is assigned:

    • A "shape" function f_L(x)   (system f)
    • A "carrier" function g_L(x) (system g)

  The functions f_L and g_L serve three roles:

    1. Symbolic:  They appear as human readable formulas in the UI.
    2. Numeric:   They can be evaluated for a user supplied x value.
    3. Acoustic:  Their numeric outputs feed a cosine based sound model:

           y(t) = A cos(2π f t)

       where A is derived from f_L(x) and f (frequency in Hz) is derived
       from g_L(x).

  The design is intended for educational and exploratory use. It shows
  how symbol systems (letters) can be mapped into mathematical and
  acoustic structures in a consistent and explainable way.

  ----------------------------------------------------------------------
  SYSTEM f(x)  (SHAPE FUNCTIONS)
  ----------------------------------------------------------------------
  General idea:
    • f(x) is primarily responsible for the "shape" or amplitude source.
    • For each letter, f_L(x) is chosen so that:
        - It is reasonably simple to read.
        - It covers a variety of function families across A to Z.
        - It tends to be real valued for a broad domain of x.
        - Where necessary, domain checks are enforced in code.

  Families used in f(x):

    1. Linear forms
       -----------------
       Basic forms of the type:
         f(x) = x + c
         f(x) = a x + b

       These give straightforward, predictable growth with respect to x.
       They appear early in the alphabet to keep A and B simple.

    2. Polynomial forms
       -----------------
       Quadratic, cubic, and quartic behaviors, such as:
         f(x) = x² + c
         f(x) = x³ - c x
         f(x) = x³ / k - x
         f(x) = (x⁴ - 1) / k

       These provide curves with turning points and more interesting
       growth behaviors. They appear scattered through the middle and
       later letters.

    3. Absolute value
       -----------------
         f(x) = |x| + c
         f(x) = |sin(k x)|

       These functions ensure nonnegative outputs and introduce sharp
       "corners" into the graph, while remaining easy to interpret.

    4. Square root and magnitude style
       ----------------------------------
         f(x) = √(x + c)
         f(x) = √(x² + c)

       These represent distance like shapes. Domain checks are needed
       when the inside of a square root must be nonnegative.

    5. Trigonometric forms
       -----------------------
         f(x) = sin(x) + c
         f(x) = cos(x) - c
         f(x) = sin(π x / k)
         f(x) = x² + sin(2x)

       These introduce periodic or mixed periodic behavior. They are
       bounded in magnitude (except for the polynomial plus sine case),
       but still vary richly with x.

    6. Logarithmic forms
       ----------------------
         f(x) = ln(x + c)
         f(x) = ln(x² + c)
         f(x) = log₂(x + c)

       These require x plus a shift to be strictly positive. They grow
       slowly and are common in information and scale modeling.

    7. Hyperbolic functions
       -------------------------
         f(x) = cosh(x / c)
         f(x) = sinh(x) / c
         f(x) = tanh(x / c)

       These are smooth and connect naturally to exponential behavior.
       They are used so that some letters live in the hyperbolic family.

    8. Rational forms
       -------------------
         f(x) = c / (x + d)

       These introduce poles and decay like behavior. Domain checks are
       required to avoid division by zero.

  Across A to Z, f(x) moves from simple linear and quadratic forms to
  more complex trigonometric, logarithmic, rational, and hyperbolic
  forms. This ensures that the alphabet samples many families of real
  valued functions rather than repeating a single pattern.

  ----------------------------------------------------------------------
  SYSTEM g(x)  (CARRIER / FREQUENCY FUNCTIONS)
  ----------------------------------------------------------------------
  General idea:
    • g(x) is the "carrier" function whose evaluated value feeds the
      sound frequency after normalization.
    • For each letter, g_L(x) is chosen so that:
        - It is distinct from the corresponding f_L(x).
        - It explores different families than f_L(x) for that letter,
          when possible.
        - It remains real valued for a broad domain of x, with domain
          checks where needed.

  Families used in g(x):

    1. Reciprocal and rational forms
       --------------------------------
         g(x) = 1 / x
         g(x) = c / (x + d)
         g(x) = c / (x² + 1)
         g(x) = c x² / (x² + 1)

       These introduce classic rational behavior and singularities. They
       are used for several letters, with checks to avoid division by
       zero.

    2. Polynomial forms
       -------------------
         g(x) = a x² + b x + c
         g(x) = a x³
         g(x) = a x³ - b x
         g(x) = a x⁴ - x²

       These are chosen to give larger magnitude values that can map to
       higher or lower frequencies after normalization. They also pair
       with the polynomial choices in the f-system but are not identical.

    3. Trigonometric and mixed trigonometric forms
       ----------------------------------------------
         g(x) = a sin(x)
         g(x) = a cos(x)
         g(x) = a cos(2x)
         g(x) = a sin(x²)
         g(x) = a sin(3x) / x
         g(x) = a sin(x) cos(x)

       These capture oscillatory behavior, including nonlinear dependence
       on x, as in sin(x²). Some are damped by division by x, so a check
       is needed for x equal to zero.

    4. Exponential and Gaussian style
       ----------------------------------
         g(x) = a e^{x / c}
         g(x) = a e^{-x}
         g(x) = a e^{-x²}

       These functions can grow or decay very quickly and are common in
       signal processing (for example in envelopes and Gaussian windows).

    5. Logarithmic forms
       ----------------------
         g(x) = a ln(x + c)
         g(x) = a log₁₀(x + c)

       These require shifted arguments to remain strictly positive. They
       grow slowly and provide moderate frequency values after scaling.

    6. Hyperbolic functions
       ------------------------
         g(x) = a cosh(x)
         g(x) = a sinh(x)

       These mirror the use of hyperbolic forms in the f-system, but with
       different coefficients and scaling.

    7. Root and magnitude style
       -----------------------------
         g(x) = a √x
         g(x) = a √(x² + 1)

       These are used where a magnitude like response that grows slower
       than a polynomial is desirable.

    8. Arctangent
       --------------
         g(x) = a arctan(x)

       This function is bounded and smooth, which ensures that after
       scaling there is a reasonable but finite range for g(x).

  Across A to Z, g(x) is designed to vary in both magnitude and form to
  provide a diverse set of base values for the sound frequency mapping.

  ----------------------------------------------------------------------
  SOUND MAPPING RULES
  ----------------------------------------------------------------------
  Given a letter L and an input value x:

    1. Compute f_L(x) and g_L(x) numerically.
       If either is not finite or not a real number for that x, the
       evaluation is considered invalid for sound purposes.

    2. Amplitude A from f_L(x):

         amp_raw  = |f_L(x)|
         A        = amp_raw / (1 + amp_raw)

       This maps any nonnegative real value into the open interval
       (0, 1). As |f_L(x)| grows large, the amplitude approaches 1
       asymptotically. As |f_L(x)| approaches 0, the amplitude
       approaches 0.

    3. Frequency f (in Hz) from g_L(x):

         g_abs = |g_L(x)|
         base  = g_abs if g_abs ≥ 1 else (1 + g_abs)
         f_Hz  = 220 + (base mod 880)

       This ensures:
         • The frequency is always at least 220 Hz.
         • The final frequency is strictly less than 220 + 880 = 1100 Hz.
         • The mapping wraps large values into this range using a
           modulus operation, which keeps the range musically manageable.

    4. The sound is then rendered as a pure tone using:

         y(t) = A cos(2π f_Hz t)

       In implementation, an audio oscillator of sine type is used,
       which differs from cosine by a phase shift only. For perceived
       pure tone frequency this difference is not significant, so a
       sine oscillator is acceptable.

  ----------------------------------------------------------------------
  WAVEFORM VISUALIZATION RULES
  ----------------------------------------------------------------------
  The waveform canvas plots a short time window of the function:

    y(t) = A cos(2π f_Hz t)

  using the current amplitude A and frequency f_Hz.

    • A fixed time window T is chosen (for example 0.01 seconds).
    • A fixed number of sample points N is chosen (for example 600).
    • For i from 0 to N - 1:
         t_i = (i / (N - 1)) * T
         y_i = A cos(2π f_Hz t_i)

      Each (t_i, y_i) pair is mapped to a pixel position:

         x_pixel = (i / (N - 1)) * canvas_width
         y_pixel = mid_y - y_i * (canvas_height / 2 - margin)

      These points are connected with a polyline to form the waveform.

    • A horizontal midline is drawn at the vertical center to indicate
      y = 0.

  ----------------------------------------------------------------------
  JSON EXPORT RULES
  ----------------------------------------------------------------------
  Two JSON exports are provided:

    1. System JSON (symbolic metadata):

         [
           { "letter": "A", "f": "f(x) = ...", "g": "g(x) = ..." },
           ...
         ]

       This records symbolic expressions, not numeric function bodies,
       suitable for documentation or loading into another system that
       has its own evaluation engine.

    2. Last evaluation JSON (sound parameters):

         {
           "letter":        L,
           "x":             x,
           "fValue":        f_L(x),
           "gValue":        g_L(x),
           "amplitude":     A,
           "frequencyHz":   f_Hz,
           "equation":      "y(t) = A cos(2π f t)"
         }

       This captures the exact numerical mapping used most recently for
       sound and waveform rendering.

  ======================================================================
  END OF SYSTEM DESIGN NOTES
  ======================================================================
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Alphabet Systems f(x), g(x), Cosine Sound, Waveform, JSON</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #ffffff;
      color: #000000;
    }
    .container {
      max-width: 600px;
      min-width: 320px;
      margin: 0 auto;
      padding: 16px;
      border: 1px solid #ccc;
      box-sizing: border-box;
    }
    h1, h2 {
      font-size: 18px;
      margin: 8px 0;
      text-align: center;
    }
    h2 {
      font-size: 14px;
      text-align: left;
      margin-top: 14px;
    }
    p.desc {
      font-size: 12px;
      line-height: 1.4;
      margin: 0 0 12px;
    }
    .letter-strip {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-bottom: 12px;
      justify-content: center;
    }
    .letter-btn {
      border: 1px solid #333;
      padding: 2px 6px;
      font-size: 11px;
      cursor: pointer;
      background: #f7f7f7;
      border-radius: 3px;
      user-select: none;
    }
    .letter-btn.active {
      background: #000000;
      color: #ffffff;
    }
    .selected-box {
      border: 1px solid #999;
      padding: 8px;
      margin-bottom: 12px;
      font-size: 12px;
      background: #fafafa;
    }
    .selected-box div {
      margin: 2px 0;
    }
    .selected-label {
      font-weight: bold;
    }

    .eval-panel,
    .sound-panel,
    .wave-panel,
    .json-panel {
      border: 1px solid #999;
      padding: 8px;
      margin-bottom: 12px;
      font-size: 12px;
      background: #fdfdfd;
    }
    .eval-panel label,
    .sound-panel label,
    .json-panel label {
      display: block;
      margin: 4px 0;
      font-size: 12px;
    }
    .eval-panel input {
      width: 100%;
      padding: 4px;
      box-sizing: border-box;
      font-size: 12px;
    }
    .eval-panel button,
    .sound-panel button,
    .json-panel button {
      margin-top: 6px;
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
      border-radius: 3px;
      border: 1px solid #333;
      background: #f3f3f3;
    }
    .eval-output,
    .sound-info {
      margin-top: 6px;
      font-size: 11px;
      line-height: 1.4;
      white-space: pre-line;
    }

    .wave-panel canvas {
      width: 100%;
      max-width: 560px;
      height: 140px;
      border: 1px solid #ccc;
      background: #ffffff;
      display: block;
      margin: 6px auto 0 auto;
    }
    .wave-caption {
      font-size: 11px;
      margin-top: 4px;
      color: #333;
    }

    .json-panel textarea {
      width: 100%;
      min-height: 120px;
      font-family: "Courier New", monospace;
      font-size: 11px;
      box-sizing: border-box;
      margin-top: 6px;
      white-space: pre;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 4px;
      text-align: left;
      vertical-align: top;
    }
    th {
      background: #f0f0f0;
    }
    .letter-col {
      width: 10%;
      text-align: center;
      font-weight: bold;
    }
    .footer-note {
      font-size: 10px;
      margin-top: 10px;
      color: #333;
    }
    @media print {
      .letter-btn {
        border: 1px solid #000;
      }
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Alphabet Systems f(x), g(x) with Sound, Waveform, and JSON</h1>
  <p class="desc">
    Each letter A through Z is assigned a pair of equations in two systems,
    <strong>f(x)</strong> and <strong>g(x)</strong>. Select a letter to see its
    equations, evaluate them at a chosen x, and then generate a cosine based
    sound and waveform. You can also export the system and the latest sound
    parameters as JSON.
  </p>

  <!-- Letter selector -->
  <div class="letter-strip" id="letterStrip">
    <!-- buttons generated by script -->
  </div>

  <!-- Selected letter symbolic display -->
  <div class="selected-box" id="selectedBox">
    <div><span class="selected-label">Letter:</span> <span id="selLetter">A</span></div>
    <div><span class="selected-label">f(x):</span> <span id="selF">f(x) = x + 1</span></div>
    <div><span class="selected-label">g(x):</span> <span id="selG">g(x) = 1/x</span></div>
  </div>

  <!-- Evaluation panel -->
  <div class="eval-panel">
    <h2>Evaluate f(x) and g(x)</h2>
    <p class="desc">
      The active letter is the one highlighted in the strip above. Enter a numeric
      value for x and press Evaluate to see numeric values for f(x) and g(x). The
      evaluation also prepares amplitude and frequency for the cosine mapping.
    </p>
    <label for="xInput">
      x value:
    </label>
    <input type="number" id="xInput" step="0.1" value="1">
    <button id="evalButton">Evaluate for current letter</button>
    <div class="eval-output" id="evalOutput">
      Waiting for evaluation. Choose a letter and press Evaluate.
    </div>
  </div>

  <!-- Cosine sound panel -->
  <div class="sound-panel">
    <h2>Cosine Sound Mapping: y(t) = A cos(2π f t)</h2>
    <p class="desc">
      After evaluation, the system derives an amplitude A from f(x) and a frequency
      f in Hz from g(x). Press the button to hear a short tone generated from the
      current letter and x value.
    </p>
    <button id="playButton">Play tone from current letter and x</button>
    <div class="sound-info" id="soundInfo">
      Sound parameters are not ready yet. Evaluate f(x) and g(x) first.
    </div>
  </div>

  <!-- Waveform preview panel -->
  <div class="wave-panel">
    <h2>Waveform Preview</h2>
    <p class="desc">
      This canvas shows a segment of y(t) = A cos(2π f t) using the latest values of
      amplitude A and frequency f. The horizontal axis represents time in seconds
      over a short window. The vertical axis shows the waveform value between −1 and 1
      scaled by A.
    </p>
    <canvas id="waveCanvas" width="560" height="140"></canvas>
    <div class="wave-caption" id="waveCaption">
      No waveform yet. Evaluate a letter and x value to draw the wave.
    </div>
  </div>

  <!-- JSON export panel -->
  <div class="json-panel">
    <h2>JSON Export</h2>
    <p class="desc">
      Use these buttons to view JSON for the full alphabet system (symbolic f(x) and g(x))
      and for the latest evaluated sound parameters. You can copy this JSON into other
      tools or scripts.
    </p>
    <button id="exportSystemButton">Show system JSON (all letters)</button>
    <button id="exportLastButton">Show last evaluation JSON</button>
    <textarea id="jsonOutput" readonly>
Press one of the buttons above to populate this JSON view.
    </textarea>
  </div>

  <!-- Full reference table -->
  <table>
    <thead>
      <tr>
        <th class="letter-col">Letter</th>
        <th>f(x)</th>
        <th>g(x)</th>
      </tr>
    </thead>
    <tbody id="eqTableBody">
      <!-- rows generated by script -->
    </tbody>
  </table>

  <div class="footer-note">
    Note: Functions use standard notation such as sin(x), cos(x), ln(x), e^x,
    tanh(x), and so on. Evaluation uses JavaScript Math functions and will report
    an error if x is outside the domain of a given function.
  </div>
</div>

<script>
  // Data structure: f(x), g(x) definitions for letters A to Z
  // Each entry contains:
  //   letter:  display letter
  //   fStr:    symbolic display string for f(x)
  //   gStr:    symbolic display string for g(x)
  //   f(x):    numeric implementation for evaluation
  //   g(x):    numeric implementation for evaluation
  const eqData = [
    {
      letter: "A",
      fStr: "f(x) = x + 1",
      gStr: "g(x) = 1/x",
      f: function (x) { return x + 1; },
      g: function (x) { return x === 0 ? NaN : 1 / x; }
    },
    {
      letter: "B",
      fStr: "f(x) = x\u00b2 + 2",
      gStr: "g(x) = 2x - x\u00b2",
      f: function (x) { return x * x + 2; },
      g: function (x) { return 2 * x - x * x; }
    },
    {
      letter: "C",
      fStr: "f(x) = 3x - 2",
      gStr: "g(x) = 3sin(x)",
      f: function (x) { return 3 * x - 2; },
      g: function (x) { return 3 * Math.sin(x); }
    },
    {
      letter: "D",
      fStr: "f(x) = x\u00b3 - 3x",
      gStr: "g(x) = 4cos(x)",
      f: function (x) { return x * x * x - 3 * x; },
      g: function (x) { return 4 * Math.cos(x); }
    },
    {
      letter: "E",
      fStr: "f(x) = \u221a(x + 4)",
      gStr: "g(x) = 5e^{-x}",
      f: function (x) { return x + 4 < 0 ? NaN : Math.sqrt(x + 4); },
      g: function (x) { return 5 * Math.exp(-x); }
    },
    {
      letter: "F",
      fStr: "f(x) = |x| + 5",
      gStr: "g(x) = 6ln(x + 1)",
      f: function (x) { return Math.abs(x) + 5; },
      g: function (x) { return x + 1 <= 0 ? NaN : 6 * Math.log(x + 1); }
    },
    {
      letter: "G",
      fStr: "f(x) = sin(x) + 6",
      gStr: "g(x) = 7x\u00b3",
      f: function (x) { return Math.sin(x) + 6; },
      g: function (x) { return 7 * x * x * x; }
    },
    {
      letter: "H",
      fStr: "f(x) = cos(x) - 7",
      gStr: "g(x) = 8/(x\u00b2 + 1)",
      f: function (x) { return Math.cos(x) - 7; },
      g: function (x) { return 8 / (x * x + 1); }
    },
    {
      letter: "I",
      fStr: "f(x) = ln(x + 8)",
      gStr: "g(x) = 9\u221ax",
      f: function (x) { return x + 8 <= 0 ? NaN : Math.log(x + 8); },
      g: function (x) { return x < 0 ? NaN : 9 * Math.sqrt(x); }
    },
    {
      letter: "J",
      fStr: "f(x) = e^x - 9",
      gStr: "g(x) = 10x\u00b2 + sin(x)",
      f: function (x) { return Math.exp(x) - 9; },
      g: function (x) { return 10 * x * x + Math.sin(x); }
    },
    {
      letter: "K",
      fStr: "f(x) = tan(x) + 10",
      gStr: "g(x) = 11e^{x/2}",
      f: function (x) { return Math.tan(x) + 10; },
      g: function (x) { return 11 * Math.exp(x / 2); }
    },
    {
      letter: "L",
      fStr: "f(x) = x\u00b2 / 11",
      gStr: "g(x) = 12tan(x/2)",
      f: function (x) { return x * x / 11; },
      g: function (x) { return 12 * Math.tan(x / 2); }
    },
    {
      letter: "M",
      fStr: "f(x) = x\u00b3 / 12 - x",
      gStr: "g(x) = 13x\u2074 - x\u00b2",
      f: function (x) { return x * x * x / 12 - x; },
      g: function (x) { return 13 * x * x * x * x - x * x; }
    },
    {
      letter: "N",
      fStr: "f(x) = x\u00b2 - 13x + 13",
      gStr: "g(x) = 14cos(2x)",
      f: function (x) { return x * x - 13 * x + 13; },
      g: function (x) { return 14 * Math.cos(2 * x); }
    },
    {
      letter: "O",
      fStr: "f(x) = sin(\u03c0x / 14)",
      gStr: "g(x) = 15/(x + 2)",
      f: function (x) { return Math.sin(Math.PI * x / 14); },
      g: function (x) { return x === -2 ? NaN : 15 / (x + 2); }
    },
    {
      letter: "P",
      fStr: "f(x) = log\u2082(x + 15)",
      gStr: "g(x) = 16x\u00b3 - 4x",
      f: function (x) { return x + 15 <= 0 ? NaN : Math.log2(x + 15); },
      g: function (x) { return 16 * x * x * x - 4 * x; }
    },
    {
      letter: "Q",
      fStr: "f(x) = \u221a(x\u00b2 + 16)",
      gStr: "g(x) = 17sin(x\u00b2)",
      f: function (x) { return Math.sqrt(x * x + 16); },
      g: function (x) { return 17 * Math.sin(x * x); }
    },
    {
      letter: "R",
      fStr: "f(x) = e^{-x / 17}",
      gStr: "g(x) = 18\u221a(x\u00b2 + 1)",
      f: function (x) { return Math.exp(-x / 17); },
      g: function (x) { return 18 * Math.sqrt(x * x + 1); }
    },
    {
      letter: "S",
      fStr: "f(x) = 18/(x + 1)",
      gStr: "g(x) = 19log\u2081\u2080(x + 3)",
      f: function (x) { return x === -1 ? NaN : 18 / (x + 1); },
      g: function (x) {
        if (x + 3 <= 0) return NaN;
        return 19 * Math.log10(x + 3);
      }
    },
    {
      letter: "T",
      fStr: "f(x) = cosh(x / 19)",
      gStr: "g(x) = 20cosh(x)",
      f: function (x) { return Math.cosh(x / 19); },
      g: function (x) { return 20 * Math.cosh(x); }
    },
    {
      letter: "U",
      fStr: "f(x) = sinh(x) / 20",
      gStr: "g(x) = 21sinh(x)",
      f: function (x) { return Math.sinh(x) / 20; },
      g: function (x) { return 21 * Math.sinh(x); }
    },
    {
      letter: "V",
      fStr: "f(x) = |sin(20x)|",
      gStr: "g(x) = 22sin(3x)/x",
      f: function (x) { return Math.abs(Math.sin(20 * x)); },
      g: function (x) { return x === 0 ? NaN : 22 * Math.sin(3 * x) / x; }
    },
    {
      letter: "W",
      fStr: "f(x) = tanh(x / 21)",
      gStr: "g(x) = 23e^{-x\u00b2}",
      f: function (x) { return Math.tanh(x / 21); },
      g: function (x) { return 23 * Math.exp(-x * x); }
    },
    {
      letter: "X",
      fStr: "f(x) = (x\u2074 - 1) / 22",
      gStr: "g(x) = 24x\u00b2/(x\u00b2 + 1)",
      f: function (x) { return (x * x * x * x - 1) / 22; },
      g: function (x) { return 24 * x * x / (x * x + 1); }
    },
    {
      letter: "Y",
      fStr: "f(x) = x\u00b2 + sin(2x)",
      gStr: "g(x) = 25tan^{-1}(x)",
      f: function (x) { return x * x + Math.sin(2 * x); },
      g: function (x) { return 25 * Math.atan(x); }
    },
    {
      letter: "Z",
      fStr: "f(x) = ln(x\u00b2 + 23)",
      gStr: "g(x) = 26sin(x)cos(x)",
      f: function (x) {
        return x * x + 23 <= 0 ? NaN : Math.log(x * x + 23);
      },
      g: function (x) {
        return 26 * Math.sin(x) * Math.cos(x);
      }
    }
  ];

  const letterStrip = document.getElementById("letterStrip");
  const eqTableBody = document.getElementById("eqTableBody");
  const selLetter = document.getElementById("selLetter");
  const selF = document.getElementById("selF");
  const selG = document.getElementById("selG");
  const xInput = document.getElementById("xInput");
  const evalButton = document.getElementById("evalButton");
  const evalOutput = document.getElementById("evalOutput");
  const playButton = document.getElementById("playButton");
  const soundInfo = document.getElementById("soundInfo");
  const waveCanvas = document.getElementById("waveCanvas");
  const waveCaption = document.getElementById("waveCaption");
  const exportSystemButton = document.getElementById("exportSystemButton");
  const exportLastButton = document.getElementById("exportLastButton");
  const jsonOutput = document.getElementById("jsonOutput");

  let currentIndex = 0;

  let lastParams = {
    letter: null,
    x: null,
    fVal: null,
    gVal: null,
    amplitude: null,
    freqHz: null
  };

  eqData.forEach((item, index) => {
    const btn = document.createElement("button");
    btn.className = "letter-btn" + (index === 0 ? " active" : "");
    btn.textContent = item.letter;
    btn.dataset.index = index.toString();
    letterStrip.appendChild(btn);

    const tr = document.createElement("tr");
    const tdL = document.createElement("td");
    const tdF = document.createElement("td");
    const tdG = document.createElement("td");

    tdL.className = "letter-col";
    tdL.textContent = item.letter;
    tdF.textContent = item.fStr;
    tdG.textContent = item.gStr;

    tr.appendChild(tdL);
    tr.appendChild(tdF);
    tr.appendChild(tdG);
    eqTableBody.appendChild(tr);
  });

  function setSelected(index) {
    currentIndex = index;
    const item = eqData[index];
    selLetter.textContent = item.letter;
    selF.textContent = item.fStr;
    selG.textContent = item.gStr;

    const buttons = document.querySelectorAll(".letter-btn");
    buttons.forEach(btn => btn.classList.remove("active"));
    buttons[index].classList.add("active");
  }

  setSelected(0);

  letterStrip.addEventListener("click", function (evt) {
    const target = evt.target;
    if (target.classList.contains("letter-btn")) {
      const idx = parseInt(target.dataset.index, 10);
      if (!isNaN(idx)) {
        setSelected(idx);
      }
    }
  });

  evalButton.addEventListener("click", function () {
    const xVal = parseFloat(xInput.value);
    if (isNaN(xVal)) {
      evalOutput.textContent = "Please enter a valid numeric value for x.";
      lastParams = {
        letter: null, x: null, fVal: null, gVal: null, amplitude: null, freqHz: null
      };
      soundInfo.textContent = "Sound parameters are not ready. Please fix x and evaluate again.";
      waveCaption.textContent = "No waveform yet. Evaluation was invalid.";
      clearWaveform();
      return;
    }

    const item = eqData[currentIndex];
    let fVal = item.f(xVal);
    let gVal = item.g(xVal);

    if (!isFinite(fVal) || !isFinite(gVal) || isNaN(fVal) || isNaN(gVal)) {
      evalOutput.textContent =
        "The chosen x value is outside the numeric domain for this letter.\n" +
        "Try a different x, or a different letter.";
      lastParams = {
        letter: null, x: null, fVal: null, gVal: null, amplitude: null, freqHz: null
      };
      soundInfo.textContent = "Sound parameters are not ready because the evaluation was invalid.";
      waveCaption.textContent = "No waveform yet. Evaluation was invalid.";
      clearWaveform();
      return;
    }

    const ampRaw = Math.abs(fVal);
    const amplitude = ampRaw / (1 + ampRaw);

    const gAbs = Math.abs(gVal);
    const base = gAbs < 1 ? 1 + gAbs : gAbs;
    const freqHz = 220 + (base % 880);

    lastParams = {
      letter: item.letter,
      x: xVal,
      fVal: fVal,
      gVal: gVal,
      amplitude: amplitude,
      freqHz: freqHz
    };

    evalOutput.textContent =
      "Letter " + item.letter + " at x = " + xVal + " gives:\n" +
      "  f(x) = " + fVal.toFixed(6) + "\n" +
      "  g(x) = " + gVal.toFixed(6) + "\n\n" +
      "Mapped sound parameters:\n" +
      "  Amplitude A (from f(x)) = " + amplitude.toFixed(4) + " (0 to 1)\n" +
      "  Frequency f (from g(x)) = " + freqHz.toFixed(2) + " Hz";

    soundInfo.textContent =
      "Ready to play y(t) = A cos(2π f t) for letter " + item.letter +
      " at x = " + xVal + ".\n" +
      "A = " + amplitude.toFixed(4) + ", f = " + freqHz.toFixed(2) + " Hz.";

    drawWaveform(amplitude, freqHz);
  });

  let audioCtx = null;

  function getAudioContext() {
    if (!audioCtx) {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) {
        alert("Web Audio API is not supported in this browser.");
        return null;
      }
      audioCtx = new AC();
    }
    return audioCtx;
  }

  playButton.addEventListener("click", function () {
    if (!lastParams || lastParams.amplitude === null || lastParams.freqHz === null) {
      alert("Sound parameters are not set. Please evaluate f(x) and g(x) first.");
      return;
    }

    const ctx = getAudioContext();
    if (!ctx) {
      return;
    }

    const duration = 2.0;
    const oscillator = ctx.createOscillator();
    const gainNode = ctx.createGain();

    oscillator.type = "sine";
    oscillator.frequency.value = lastParams.freqHz;

    gainNode.gain.value = lastParams.amplitude;

    oscillator.connect(gainNode).connect(ctx.destination);

    const now = ctx.currentTime;
    oscillator.start(now);
    oscillator.stop(now + duration);
  });

  const waveCtx = waveCanvas.getContext("2d");

  function clearWaveform() {
    waveCtx.clearRect(0, 0, waveCanvas.width, waveCanvas.height);
    waveCtx.beginPath();
    waveCtx.moveTo(0, waveCanvas.height / 2);
    waveCtx.lineTo(waveCanvas.width, waveCanvas.height / 2);
    waveCtx.strokeStyle = "#cccccc";
    waveCtx.lineWidth = 1;
    waveCtx.stroke();
  }

  clearWaveform();

  function drawWaveform(amplitude, freqHz) {
    const width = waveCanvas.width;
    const height = waveCanvas.height;
    const midY = height / 2;

    waveCtx.clearRect(0, 0, width, height);
    waveCtx.beginPath();
    waveCtx.moveTo(0, midY);
    waveCtx.lineTo(width, midY);
    waveCtx.strokeStyle = "#cccccc";
    waveCtx.lineWidth = 1;
    waveCtx.stroke();

    const timeWindow = 0.01;
    const sampleCount = 600;

    waveCtx.beginPath();
    for (let i = 0; i < sampleCount; i++) {
      const t = (i / (sampleCount - 1)) * timeWindow;
      const y = amplitude * Math.cos(2 * Math.PI * freqHz * t);

      const xPixel = (i / (sampleCount - 1)) * width;
      const yPixel = midY - y * (height / 2 - 4);

      if (i === 0) {
        waveCtx.moveTo(xPixel, yPixel);
      } else {
        waveCtx.lineTo(xPixel, yPixel);
      }
    }

    waveCtx.strokeStyle = "#000000";
    waveCtx.lineWidth = 1.5;
    waveCtx.stroke();

    waveCaption.textContent =
      "Waveform preview: y(t) = A cos(2π f t) over " + timeWindow + " seconds. " +
      "A = " + amplitude.toFixed(4) + ", f = " + freqHz.toFixed(2) + " Hz.";
  }

  exportSystemButton.addEventListener("click", function () {
    const systemExport = eqData.map(item => ({
      letter: item.letter,
      f: item.fStr,
      g: item.gStr
    }));

    const jsonText = JSON.stringify(systemExport, null, 2);
    jsonOutput.value = jsonText;
  });

  exportLastButton.addEventListener("click", function () {
    if (!lastParams || lastParams.letter === null) {
      jsonOutput.value =
        "// No valid evaluation has been performed yet.\n" +
        "// Evaluate a letter and x value first.";
      return;
    }

    const lastExport = {
      letter: lastParams.letter,
      x: lastParams.x,
      fValue: lastParams.fVal,
      gValue: lastParams.gVal,
      amplitude: lastParams.amplitude,
      frequencyHz: lastParams.freqHz,
      equation: "y(t) = A cos(2π f t)"
    };

    const jsonText = JSON.stringify(lastExport, null, 2);
    jsonOutput.value = jsonText;
  });
</script>
</body>
</html>
